#并发

	#主内存与工作内存：java中实例字段，静态字段、构成数组对象的元素都存放在主内存中，每个线程需要操作共享变量都需要与主内存互交完成
	
	#内存互交操作8种
		#锁定lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
		#解锁unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
		#读取read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
		#载入load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
		#使用use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
		#赋值assign：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
		#存储store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
		#写入write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
	#read与load、store与write必须一一对应。
	
	#并发3个特征
		#原子性：基本数据类型的访问读写具备原子性(long和double两个64位数据非原子性协议，在32位的计算机上)，synchronized可以保证更大范围的原子性
		#可见性：当一个线程修改了共享变量，其他线程能够立即得知新值，volatile、synchronized、final都可以保证可见性
		#有序性：java天然有序：线程内表现为串行的语义，一个线程观察另一个线程，所有操作都是无序的：指令重排和工作内存与主内存同步延迟现象
	
	#关键字volatile
		#轻量级同步机制，不保存副本，每次使用前立即从主内存刷新
		#保证可见性，但不保证原子性，所以当有多线程对它进行修改操作，可能获得不正确值
		#禁止指令重排序优化
		#使用场景：运算不依赖当前结果或只有一个线程会修改变量的值、不需要其他状态变量共同参与不变约束，比如ThreadPoolExecutor线程池类中定义了很多volatile变量，以保证其他变量的可见性
		#volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。
	
	#线程
		#定义：线程是cpu调度最小单位(进程是cpu资源分配的最小单位)，线程是建立在进程的基础上的一次程序运行单位，各个线程既可以共享进程资源
		#创建线程实现的三种方式：
			#继承Thread类，重写run方法
			#实现Runnable接口，重写run方法
			#通过Callable和Future创建线程，过程复杂，不常用
			#三种方式对比：
				#1和3都是实现接口，还可以继承其他类、多线程可以共享一个target对象，缺点访问当前线程使用Thread.currentThread()方法
				#2使用继承方式不可再继承其他类，获取当前线程直接用this即可
				#Callable和Future方式可以有返回值，而Runnable没有
			#建议实现Runnable接口来创建线程
		#线程共有10个优先级
		#5种状态
			#新建new：创建后尚未启动的线程处于这种状态。start() -> running
			#运行runable：正在执行或等待cpu分配执行时间。Thread.yield()：线程放弃运行，将CPU的控制权让出。
			#等待waiting：
				#无限期等待：需要被其他线程显示唤醒 notify()/notifyAll() -> Running -> wait()
					#没有设置Timeout参数的Object.wait（）方法。
					#没有设置Timeout参数的Thread.join（）方法
					#LockSupport.park（）方法
				#限期等待：不需要其他线程显示唤醒
					#Thread.sleep（）方法
					#设置了Timeout参数的Object.wait（）方法
					#设置了Timeout参数的Thread.join（）方法
					#LockSupport.parkNanos（）方法
					#LockSupport.parkUntil（）方法
					
			#阻塞blocked：等待其他线程放弃这个锁，synchronized
			#结束terminated：已终止线程的线程状态，线程已经结束执行。run()结束
		#线程安全
			#定义：如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的
			#实现方法：
				#阻塞同步：synchronized和重入锁(ReentrantLock)
				#非阻塞同步：先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施
				#无同步：有些代码天生安全，比如不涉及共享数据
		#线程池
			#定义：频繁的创建和销毁线程会消耗大量资源，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理
			#实现：java.util.concurrent.ThreadPoolExecutor
			#优点：
				#避免线程的创建和销毁带来的性能开销。
				#避免大量的线程间因互相抢占系统资源导致的阻塞现象。
				#能够对线程进行简单的管理并提供定时执行、间隔执行等功能
	
		#死锁
			#定义：多个线程同时等待其他线程释放锁，导致被无限期阻塞
			#原因：A线程持有锁1，这时主内存的锁1变量进入锁定状态，其他想获得此变量的的线程必须等待。B线程持有锁2，主内存中的锁2变量进入锁定状态。
			##这时A线程再去获取锁2，B线程再去获取锁1，而此时A、B线程都没有对原先锁变量进行解锁，故A线程等待B线程释放锁2，而B线程等待A线程释放锁1。
			##这时就出现了A、B线程同时被无限期阻塞，故导致死锁
			#避免方法：
				#加锁顺序：上述例子出现死锁因为A、B线程加锁的顺序不同，如果按照相同顺序，则可以避免死锁
				#加锁时限：给锁加一个超时时间，若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。
				##这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具
				#死锁检测：死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。
				##还是上述例子，线程A持有锁1，请求锁2，线程B持有锁2，请求锁1。这时可以让线程A去检测线程B是否已经请求了线程A当前锁持有的锁，如果线程B的确是在请求，
				##则线程A取消请求，并释放锁1，回退和等待。当然现实可能多条线程交叉，它需要递进地检测。
