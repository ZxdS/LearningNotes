# GC机制

	
	    #判断对象死亡算法
			#引用计数法：给对象添加一个引用计算器，每当有地方引用它就加1，引用失效就减1，为0时就表示对象不再被使用，简单效率高，但是存在一个对象之间相互循环引用问题。
			#可达性分析算法：主流语言都采用此算法判断对象存活，原理是对象到GC Roots是不可达的，就认定为此对象可回收。
			##在java语言中，可作为GC Roots的对象包括：虚拟机栈中引用的对象、java堆类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象
	
		#垃圾收集算法
			#标记-清除算法：最基础的收集算法，后续算法都是基于这种思路改进。分为标记和清楚两个过程，但是效率不高，且产生大量不连续内存碎片。再分配大对象时，可能无法找到足够的连续内存而导致提前出发一次gc
			#复制算法：实现简单，效率高，现在商用虚拟机都采用这种算法来回收新生代。将eden和其中一块survivor中存活的对象复制到另一块survivor区，然后清理eden和用过的survivor区
			#标记整理算法：复制算法当对象存活率较高时效率会降低，所以根据老年代特点设计出这种算法，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
			#分代收集：根据对象存活周期不同选择以上三种不同的算法去收集，java堆新生代使用 复制算法，旧生代使用 标记-整理算法
	
		#垃圾回收器
			#串行垃圾回收器Serial：最基本，最古老的收集器，只用一个单独的线程进行垃圾回收，冻结所有应用程序进行工作，客户端可能会用
			#并行垃圾回收器Parallel：使用多线程进行垃圾回收，停止其他所有应用程序线程
			#并发标记扫描垃圾回收器CMS：基于标记-清除算法实现，主要有四步：初始标记-并发标记-重新标记-并发清除，初始标记，重新标记任要停止其他应用线程。并发收集，低停顿。缺点使用标记-清除算法
			#G1垃圾回收器：目前最先进的收集器，替换CMS，将整个java堆划分为多个大小相等的独立区。特点：并行与并发、分代收集、空间整合(标记-整理)、 可预测停顿