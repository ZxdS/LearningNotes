# Java 内存模型

1.程序计数器：线程私有，一块较小的内存空间，是jvm执行程序的流水线，存放一些跳转指令,维护下一个将要执行指令的地址。(仅限于Java方法, Native方法该计数器值为undefined).

2.java虚拟机栈：线程私有，每个方法执行都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法被调用至返回的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程(VM提供了-Xss来指定线程的最大栈空间, 该参数也直接决定了函数调用的最大深度).

3.本地方法栈：虚拟机使用到的Native方法服务

4.java堆：-Xmx最大堆内存 -Xms初始堆内存。所有线程共享，GC收集器管理的主要区域，jvm创建的对象存放于此，主要分为新生代和旧生代，而新生代又分为eden区(80%)，from survivor(10%)和to survivor区，之所以这么分是因为新生代中98%的对象是朝生夕死，

所以采用复制算法的GC策略，将eden和其中一块survivor中存活的对象复制到另一块survivor区，然后清理eden和用过的survivor区

5.方法区：所有线程共享，方法区是jvm规范中定义的一个概念，存放加载的类，常量，静态变量，JIT编译后的代码等数据。hotspot中用永久代来实现，别的jvm没有永久代的概念
	在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在native memory的CodeCache区域，其他都存放在永久代；
	在Java 7中，Symbol的存储从PermGen移动到了native memory，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）；
	在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,-XX:MaxPermSize 参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。

6.元空间：jdk1.8中移除永久代，而使用元空间，两者都是对jvm方法区的实现，不过元空间并不在虚拟机中，而是使用本地内存。
		使用元空间代替永久代的原因：
			#字符串存在永久代中，容易出现性能问题和内存溢出
			#类及方法信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
			#永久代会为GC带来不必要的复杂度，并且回收效率偏低
			#oracle可能会将HotSpot与JRockit合二为一

		内存分配原则：
			#对象优先在Eden分配，当没有足够空间触发Minor GC
			#大对象直接进入老年代，很长的字符串及数组都是大对象
			#长期存活的对象进入老年代，新生代中经历一次Minor GC年龄就增加一岁，当达到默认的15岁，就进入老年代，这个默认值可以设置
	
		注：直接内存：直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提供了基于Channel与Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存(java.nio.ByteBuffer.allocateDirect()), 然后使用DirectByteBuffer对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 
			这样就避免了在Java堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能. 显然, 本机直接内存的分配不会受到Java堆大小的限制(即不会遵守-Xms、-Xmx等设置), 但既然是内存, 则肯定还是会受到本机总内存大小及处理器寻址空间的限制, 因此动态扩展时也会出现OutOfMemoryError异常.



## java内存区域

一.  运行时数据区域

　　Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域. 

　　Java虚拟机所管理的内存将会包括以下几个运行时数据区域:  

![img](https://images2017.cnblogs.com/blog/1241136/201711/1241136-20171121143944665-1196122165.jpg)

**1. 程序计数器**

　　　　1)程序计数器(Program CounterRegister) 是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器. **在虚拟机的概念模型里, 字节码解释器工作时就是通过改变这个计数器的值来选去吓一跳需要执行的字节码指令, 分支, 循环, 跳转, 异常处理, 线程恢复等基础功能都需要依赖这个计数器来完成**.

　	解释到这里可能有的小伙伴还是很懵。前面我们谈到Java 程序的执行流程里面谈到了：

​         Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后
由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。

​		2)由于Java 虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，任何时候，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能够恢复发到正确的位置，我们就需要程序计数器来记录程序执行的位置。举个CPU 的解释栗子：当你在看砖头书的时候你妈叫你去吃饭，作为一个肥宅，肯定快乐的扔掉书就跑了。但你又继续啃书的时候才发现不知道自己看到哪了。怎么解决？下次卡个书签呗。程序计数器就是这个道理，记录程序的字节码的执行位置，当当前线程重新拥有CPU 时可以继续执行剩下的代码。

通过上面的解释可以很清晰的理解**不同的线程肯定不能共用一个程序计数器，每条线程都需要有一个独立的的程序计数器，各条线程间计数器互不影响，独立存储**。我们称这类内存区域为”**线程私有**”。在JVM规范中规定，如果线程执行的是一个Java方法，则程序计数器中保存的是当前需要执行的指令的字节码地址；如果线程执行的是native方法，则程序计数器中的值是空(undefined)。前面我们提到了：程序计数器是一个很小的内存地址。此内存区域是唯一一个在Java 虚拟机中没有规定任何内存泄露（OutOfMemoryError）情况的区域，程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变。就像书签一样，不管卡在那，它自己不会变。



**2. Java虚拟机栈**

　　　　1)与程序计数器一样, Java虚拟机栈(Java Virtual Machine Stacks) 也是线程私有的, 它的生命周期与线程相同. 虚拟机栈描述的是Java方法执行的内存模型: **每个方法被执行的时候都会同时创建一个栈帧(Stack Frame) 用于存储局部变量表, 操作栈, 动态链接, 方法出口等信息. 每一个方法被调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.**

​	程序每执行一个方法，就会分配一个栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么在使用递归方法的时候容易导致栈内存溢出的现象了。  ![Java èææºæ ](https://img-blog.csdn.net/20180819174141539?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTA2NjI3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

　　　　2)局部变量表存放了编译期可知的各种基本数据类型(Boolean, byte , char, short, int, float , long , double), 对象引用(reference类型, 它不等同于对象本身, 根据不同的虚拟机实现, 他可能是一个指向对象起始地址的引用指针, 也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).

　　　　3)其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot), 其余的数据类型只占用一个, 局部变量表所需的内存空间在编译期间完成分配, 当进入一个方法时, 这个方法需要在帧中分配多大的局部变量空间是完全确定的, 在方法运行期间不会改变局部变量表的大小.

​		4)操作数栈

​	操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。 

​		5）两种异常状况  

- 　　如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverflowError异常; 
- 　　如果虚拟机栈可以动态扩展(当前大部分Java虚拟机都可动态拓展, 只不过Java虚拟机规范中也允许固定长度的虚拟机栈),当拓展时无法申请到足够的内存时会抛出OutOfMemoryEoor异常.

**3.本地方法栈**

　　　　1)本地方法栈(Native Method Stacks) 与虚拟机栈所发挥的作用是非常相似的, 其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务, 而本地方法栈则是为虚拟机使用到Native方法服务. 虚拟机规范中对本地方法栈中的方法使用的语言, 使用方式与数据结构并没有强制规定, 因此具体的虚拟机可以自由实现它. 甚至有的虚拟机(譬如 Sun HotSpot 虚拟机)直接就把本地方法栈和虚拟机栈合二为一. 与虚拟机栈一样, 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常.

**4.Java** **堆**

　　　　1) 对于大多数应用来说, Java堆(Java Heap) 是Java虚拟机所管理的内存中最大的一块. Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建. 此内存区域的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存. 这一点在Java虚拟机规范中描述的是: 所有的对象实例以及数组都要在堆上分配, 但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟, 栈上分配, 标量替换优化技术将会导致一些微妙的变化发生, 所有的对象都分配在堆上也逐渐变得不是那么"绝对"了.

　　　　2) Java 堆是垃圾收集器管理的主要区域, 因此很多时候也被称做"GC堆"(Garbage Collected Heap), 如果从内存回收的角度看, 由于现在收集器基本都是采用的分代收集算法, 所以Java堆中还可以细分为: 新生代和老年代; 在细致一点的有Eden空间, From Survivor空间, To Survivor空间等. 如果从内存分配的角度看, 线程共享的Java对中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB). 不过, 无论如何划分, 都与存放内容无关, 无论哪个区域, 存储的都仍然是对象实例, 进一步划分的目的是为了更好的回收内存, 或者更快的分配内存. 

　　　　3) 根据Java虚拟机规范的规定, Java堆上可以处于物理上不连续的内存空间中, 只要逻辑上是连续的即可, 就像我们的磁盘空间一样. 在实现时, 既可以实现成固定大小的, 也可以是可拓展的, 不过当前主流的虚拟机都是按照可拓展来实现的( 通过-Xms 初始化堆, -Xmx 最大堆空间), 如果在堆中没有内存完成实例分配, 并且堆也无法在拓展时, 将会抛出OutOfMemoryError异常.

**5. 方法区**

　　　　1) 方法区(Method Area) 与Java堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据. 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分, 但是它却有一个别名叫做Non-Heap非堆, 目的应该是与Java Heap 区分开来.

**6.运行时常量池**

　　　　1) 运行时常量池(Runtime Constant Pool) 是方法区的一部分. Class文件中除了有类的版本, 字段,方法, 接口等描述信息外, 还有一项信息是常量池(Constant Pool Table), 用于存放编译期生成的各种字面量和符号引用, 这部分内容将在类加载后存放到方法区的运行时常量池中. 

　　　　2) 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性, Java语言并不要求常量一定只能在编译期产生, 也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入翅中, 这种特性被开发人员利用的比较多的便是String类的intern() 方法.

**7. 直接内存**

　　　　1) 直接内存(Direct Memory) 并不是虚拟机运行时数据区的一部分, 也不是Java虚拟机规范中定义的内存区域, 但是这部分内存也被频繁地使用, 而且也可能导致OutOfMemoryError异常出现. 显然, 本机直接内存的分配不会受到Java堆大小的限制, 但是, 既然是内存, 则肯定还是会受到本机总内存的大小及处理器寻址空间的限制. 服务器管理员配置虚拟机参数时, 一般会根据实际内存-Xmx等参数信息, 但经常会忽略到直接内存, 使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制), 从而导致动态扩展时出现OutOfMemoryError异常. 

