# 类加载

	类加载过程五步：
			#加载
				#通过一个类的全限定名来获取定义此类的二进制字节流
				#将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
				#在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口
			#验证
				#文件格式验证：验证字节流是否符合Class文件格式规范
				#元数据验证：是否有父类、父类是否继承final修饰类、不是抽象类是否实现父类或接口需要实现的方法
				#字节码验证：确定语义合法、符合逻辑
				#引用符号验证：检查引用的类、字段、方法的访问性是否可悲当前类访问等。
			#准备
				#为类变量分配内存并设置初始化值
			#解析
				#类或接口解析
				#字段解析
				#类方法解析
				#接口方法解析
			#初始化
				#执行<clinit>()方法：调用静态代码块和给静态变量赋值，先从父类开始
				
		#类加载器
			#种类4类：启动类加载器(c++实现)、扩展类加载器->应用程序类加载器->自定义类加载器
			#双亲委派模型：一个类加载器收到类加载请求，先判断自己是否已经加载了此类，如果没有则会把这个请求交给父类加载器完成，
			##父类加载器同样判断自己是否已加载，如果没有加载则一层一层往上，直到有父类反馈这个类不该自己加载，子类才自己去加载，优点：安全，避免重复加载
			#注意：很多文章介绍类加载等级时将启动类加载器列在扩展类加载器的上一级，其实不对，因为启动类加载器由c++实现，属于jvm的一部分，并不属于jvm的类等级结构，
			##而且启动类加载器也没有子类